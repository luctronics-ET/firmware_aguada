# Firmware Aguada - Regras e Padrões de Desenvolvimento

## 1. ARQUITETURA DO SISTEMA

### Topologia
```
[Nodes ESP32-C3] --ESP-NOW--> [Gateway ESP32] --WiFi--> [Backend PHP/MySQL]
[Node Nano ETH] ---------------Ethernet---------------> [Backend PHP/MySQL]
```

### Componentes
- **Nodes**: Sensores ultrassônicos (HC-SR04) + ESP32-C3 ou Arduino Nano Ethernet
- **Gateway**: ESP32 DevKit V1 (receptor ESP-NOW, forward HTTP)
- **Backend**: PHP + MySQL (ingest_sensorpacket.php)

## 2. PROTOCOLO DE COMUNICAÇÃO

### SensorPacketV1 (Binary para ESP-NOW)
```c
typedef struct __attribute__((packed)) {
    uint8_t  version;        // = 1
    uint8_t  node_id;        // 0-255
    uint8_t  mac[6];         // STA MAC
    uint32_t seq;            // Sequência monotônica
    int16_t  distance_cm;    // Distância medida
    int16_t  level_cm;       // Nível calculado
    uint8_t  percentual;     // 0-100
    uint32_t volume_l;       // Litros
    int16_t  vin_mv;         // Tensão em mV
    uint8_t  flags;          // Bit 0: is_alert
    uint8_t  alert_type;     // 0=none, 1=rapid_drop, 2=rapid_rise, 3=sensor_stuck
    int8_t   rssi;           // Preenchido pelo gateway
    uint32_t ts_ms;          // Timestamp do gateway
} SensorPacketV1;
```

### AckPacket (Gateway → Node)
```c
typedef struct __attribute__((packed)) {
    uint8_t  magic;          // 0xAC
    uint8_t  version;        // = 1
    uint8_t  node_id;        // Node sendo confirmado
    uint32_t ack_seq;        // Sequência confirmada
    int8_t   rssi;           // RSSI medido pelo gateway
    uint8_t  status;         // 0=OK, 1=queued, 2=error
    uint8_t  gateway_id;     // Qual gateway (0-2)
    uint8_t  reserved;
} AckPacket;
```

### JSON (Arduino Nano → Backend)
```json
{
  "version": 1,
  "node_id": 10,
  "mac": "AA:BB:CC:DD:EE:01",
  "seq": 1234,
  "distance_cm": 72,
  "level_cm": 398,
  "percentual": 88,
  "volume_l": 70755,
  "vin_mv": 0,
  "flags": 0,
  "alert_type": 0,
  "rssi": 0,
  "ts_ms": 123456789
}
```

## 3. CONFIGURAÇÃO DOS NODES

### Nodes Ativos
| Node ID | MAC | Tipo | Reservatório | Volume | Nivel Max | Offset |
|---------|-----|------|--------------|--------|-----------|--------|
| 1 | 20:6E:F1:6B:77:58 | ESP32-C3 | RCON (Consumo) | 80,000L | 450cm | 20cm |
| 2 | DC:06:75:67:6A:CC | ESP32-C3 | RCAV (Incêndio) | 80,000L | 450cm | 20cm |
| 3 | 80:F1:B2:50:31:34 | ESP32-C3 | RCB3 (Bombas 03) | 80,000L | 450cm | 20cm |
| 4 | DC:B4:D9:8B:9E:AC | ESP32-C3 | CIE1 (Dual sensor 1) | 245,000L | 550cm | 20cm |
| 5 | DC:B4:D9:8B:9E:AC | ESP32-C3 | CIE2 (Dual sensor 2) | 245,000L | 550cm | 20cm |
| 10 | AA:BB:CC:DD:EE:01 | Nano ETH | RCON Backup | 80,000L | 450cm | 20cm |

### Gateway
- **MAC**: 80:F3:DA:62:A7:84
- **WiFi**: SSID "luciano", canal 11
- **IP**: 192.168.0.130 (DHCP)
- **Backend**: http://192.168.0.117:8080/ingest_sensorpacket.php

## 4. PADRÕES DE CÓDIGO

### ESP-IDF (Nodes ESP32-C3 e Gateway)
- **Framework**: ESP-IDF v5.x+
- **Build**: `idf.py build`, `idf.py flash`, `idf.py monitor`
- **Canal ESP-NOW**: Fixo no 11 (hardcoded)
- **Intervalo de transmissão**: 30 segundos
- **Timeout ACK**: 500ms

### Arduino (Nano Ethernet)
- **Framework**: Arduino AVR
- **Board**: Arduino Nano (ATmega328P old bootloader)
- **Compilador**: arduino-cli
- **Limites**: Flash 30,720 bytes (usar com cautela)

### Componentes Compartilhados
- **`common/telemetry_packet.h`**: Definições de structs
- **`components/ultrasonic01/`**: Driver HC-SR04 (header-only)
- **`components/level_calculator/`**: Cálculo nível/volume (header-only)

## 5. DETECÇÃO DE ANOMALIAS

### Tipos de Alerta
```c
#define ALERT_NONE         0  // Sem alerta
#define ALERT_RAPID_DROP   1  // Nível caiu >10cm (vazamento)
#define ALERT_RAPID_RISE   2  // Nível subiu >10cm (enchente/bomba presa)
#define ALERT_SENSOR_STUCK 3  // Leitura inalterada por 5+ ciclos
```

### Implementação
- **Nodes**: Calculam flags/alert_type localmente
- **Gateway**: Valida e adiciona contexto (RSSI, timestamp)
- **Backend**: Registra alertas e pode disparar notificações

## 6. FLUXO DE DADOS

### Node → Gateway (ESP-NOW)
1. Node mede distância HC-SR04
2. Calcula level_cm, percentual, volume_l
3. Detecta anomalias
4. Envia SensorPacketV1 (28 bytes) via ESP-NOW
5. Aguarda AckPacket (500ms timeout)
6. Retry se necessário (exponential backoff)

### Gateway → Backend (HTTP POST)
1. Gateway recebe pacote ESP-NOW
2. Adiciona RSSI e timestamp
3. Converte para JSON
4. POST para /ingest_sensorpacket.php
5. Se backend offline: salva na NVS (até 50 pacotes)

### Nano → Backend (HTTP POST direto)
1. Nano mede distância HC-SR04
2. Calcula level_cm, percentual, volume_l
3. Detecta anomalias
4. POST JSON direto para backend
5. Sem ACK (TCP garante entrega)

## 7. PERSISTÊNCIA

### NVS (Non-Volatile Storage)
- **Nodes**: Salvam `seq` (sequência) para sobreviver resets
- **Gateway**: Fila de até 50 pacotes pendentes (backend offline)

### EEPROM (Arduino Nano)
- **Configuração completa**: node_id, IPs, offsets, volumes
- **Validação**: Magic byte (0xAC) + checksum

## 8. REDUNDÂNCIA

### Node 1 + Node 10 (RCON)
- Mesmo reservatório medido por 2 sensores independentes
- Node 1: ESP32-C3 → ESP-NOW → Gateway → Backend
- Node 10: Nano Ethernet → HTTP direto → Backend
- Backend pode comparar leituras e detectar discrepâncias

## 9. DEBUGGING

### Serial Monitor
- **ESP32**: `idf.py monitor` ou `idf.py monitor --no-reset`
- **Arduino**: `arduino-cli monitor -p /dev/ttyUSB0 -c baudrate=115200`

### Logs Importantes
- **Node**: Taxa de ACK, seq, distance_cm, level_cm
- **Gateway**: Pacotes recebidos, RSSI, HTTP status
- **Backend**: SQL inserts, alertas disparados

### Troubleshooting
1. **ESP-NOW falha**: Verificar canal 11 (node + gateway + router)
2. **Backend offline**: Verificar NVS queue no gateway
3. **Leituras inválidas**: HC-SR04 desconectado ou obstáculo próximo
4. **Memory overflow**: Arduino Nano tem apenas 30KB flash

## 10. BOAS PRÁTICAS

### Código
- **Sem floats**: Usar int/int64 para cálculos (eficiência)
- **Header-only libs**: Componentes compartilhados como inline functions
- **Packed structs**: `__attribute__((packed))` para binary protocols
- **F() macro**: Arduino strings em PROGMEM (economizar RAM)

### Hardware
- **HC-SR04**: VCC=5V, TRIG/ECHO em GPIOs 3.3V tolerant
- **ESP32-C3**: GPIO1=TRIG, GPIO0=ECHO (nodes 1-3)
- **ESP32-C3 Dual**: GPIO1/0 + GPIO3/2 (node 4/5)
- **Nano**: D6=TRIG, D5=ECHO

### Rede
- **ESP-NOW**: Canal fixo 11
- **WiFi Gateway**: Mesmo canal 11 (STA mode)
- **Ethernet Nano**: IP estático 192.168.0.210
- **Backend**: IP fixo 192.168.0.117:8080

## 11. COMANDOS ÚTEIS

### ESP-IDF
```bash
# Compilar node
cd node_ultra1
idf.py set-target esp32c3
idf.py build

# Gravar
idf.py -p /dev/ttyACM0 flash

# Monitor
idf.py -p /dev/ttyACM0 monitor
idf.py -p /dev/ttyACM0 monitor --no-reset

# Limpar builds
./limpar_builds.sh
```

### Arduino CLI
```bash
# Compilar
arduino-cli compile --fqbn arduino:avr:nano:cpu=atmega328old .

# Gravar
arduino-cli upload -p /dev/ttyUSB0 --fqbn arduino:avr:nano:cpu=atmega328old .

# Monitor
arduino-cli monitor -p /dev/ttyUSB0 -c baudrate=115200
```

### Backend (separado)
```bash
cd ~/firmware_aguada
./start_services.sh    # MySQL + PHP
./status_services.sh   # Verificar status
./stop_services.sh     # Parar serviços
```

## 12. ESTRUTURA DE ARQUIVOS

```
firmware_aguada/firmware/
├── common/
│   └── telemetry_packet.h          # Structs compartilhadas
├── components/
│   ├── ultrasonic01/
│   │   └── ultrasonic01.h          # Driver HC-SR04
│   └── level_calculator/
│       └── level_calculator.h      # Cálculos de nível/volume
├── node_ultra1/                    # Node 1 (RCON)
│   ├── main/node_ultra1.cpp
│   ├── CMakeLists.txt
│   └── sdkconfig.defaults
├── node_ultra2/                    # Node 2 (RCAV)
├── node_ultra3/                    # Node 3 (RCB3)
├── node_cie_dual/                  # Node 4+5 (CIE Dual)
├── gateway_devkit_v1/              # Gateway ESP32
│   ├── main/main.c
│   └── sdkconfig.defaults
├── arduino/
│   └── nano_ethernet_ultra/        # Node 10 (Nano ETH)
│       ├── nano_ethernet_ultra.ino
│       └── config_manager.h
├── memory-bank/                    # Contexto do projeto
├── nodes_config_REAL_MACS.sql     # Config backend com MACs reais
└── README.md
```

## 13. FRONTEND - DASHBOARD WEB

### Tecnologia
- **Template**: TailAdmin (Tailwind CSS + Alpine.js + ApexCharts)
- **Localização**: `frontend/aguada-dashboard/`
- **Build**: Webpack 5
- **Deploy**: Static site ou integrado com backend PHP

### Endpoints da API

O dashboard consome 3 endpoints principais:

#### 1. GET /api/get_sensors_data.php
Status atual de todos os sensores (última leitura por node).

**Response:**
```json
{
  "status": "success",
  "sensors": [{
    "node_id": 1,
    "name": "RCON",
    "mac": "20:6E:F1:6B:77:58",
    "distance_cm": 72,
    "level_cm": 398,
    "percentual": 88,
    "volume_l": 70755,
    "capacity": 80000,
    "rssi": -45,
    "last_update": "2025-12-18 08:30:45",
    "flags": 0,
    "alert_type": 0
  }]
}
```

#### 2. GET /api/get_recent_readings.php
Leituras recentes (últimas N entradas).

**Parameters:**
- `limit` (opcional, default: 50)
- `node_id` (opcional, filtrar por node)

#### 3. GET /api/get_history.php
Histórico agregado por minuto (médias).

**Parameters:**
- `hours` (opcional, default: 24)
- `node_id` (opcional)

### Features do Dashboard

- **Cards de Status**: Um card por node com:
  - Nome do reservatório
  - Status online/offline (threshold 3 min)
  - Progress bar com cores (verde/azul/amarelo/vermelho)
  - Volume atual vs capacidade
  - RSSI, distância, nível
  - Badges de alerta

- **Gráficos**:
  - Histórico de níveis (24h)
  - Distribuição de volume
  - Qualidade de sinal (RSSI)

- **Tabela de Leituras**: Últimas 20 leituras com todos os campos

- **Auto-Refresh**: Atualização a cada 5 segundos

### Setup

```bash
cd frontend/aguada-dashboard
npm install
npm start          # Dev server http://localhost:8080
npm run build      # Build para produção
```

### Integração com Firmware

100% compatível com `SensorPacketV1`. Backend converte binary → JSON.

Mapeamento de nodes:
| ID | Nome | MAC | Capacidade |
|----|------|-----|------------|
| 1 | RCON | 20:6E:F1:6B:77:58 | 80,000L |
| 2 | RCAV | DC:06:75:67:6A:CC | 80,000L |
| 3 | RCB3 | 80:F1:B2:50:31:34 | 80,000L |
| 4 | CIE1 | DC:B4:D9:8B:9E:AC | 245,000L |
| 5 | CIE2 | DC:B4:D9:8B:9E:AC | 245,000L |
| 10 | RCON-ETH | AA:BB:CC:DD:EE:01 | 80,000L |

## 14. PRÓXIMOS PASSOS

### Hardware
- [ ] Conectar HC-SR04 nos nodes 1, 2, 3, 10
- [ ] Conectar HC-SR04 duplo no node 4 (CIE)
- [ ] Fixar sensores nos reservatórios (distância correta)

### Backend
- [ ] Executar nodes_config_REAL_MACS.sql
- [ ] Iniciar backend: ./start_services.sh
- [ ] Verificar ingestion: SELECT * FROM telemetry_processed;

### Frontend
- [x] Copiar TailAdmin para frontend/aguada-dashboard
- [x] Criar aguada-telemetry.html (dashboard principal)
- [x] Criar APIs: get_sensors_data.php, get_recent_readings.php, get_history.php
- [x] Mapear todos os 6 nodes (1-5 + 10)
- [ ] Implementar gráficos ApexCharts completos
- [ ] Adicionar WebSocket para updates em tempo real
- [ ] Testar dashboard com dados reais
- [ ] Deploy para produção

### Testes
- [ ] Validar medições contra régua física
- [ ] Testar alertas (simular vazamento)
- [ ] Validar redundância Node 1 vs Node 10
- [ ] Stress test: gateway com 50 pacotes NVS
- [ ] Testar dashboard em diferentes resoluções

### Otimizações
- [ ] Ajustar filtro Kalman se leituras ruidosas
- [ ] Tunar thresholds de anomalias
- [ ] Implementar autenticação no dashboard
- [ ] Adicionar notificações (email/Telegram)
- [ ] Criar sistema de balanço hídrico completo
- [ ] Mobile app (PWA)

---

**Última atualização**: 18 de dezembro de 2025
**Versão do protocolo**: SensorPacketV1
**Firmware compilado e testado**: ✅ Todos os nodes + gateway + nano
**Frontend**: ✅ TailAdmin integrado com backend
